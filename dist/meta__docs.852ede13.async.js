"use strict";(self.webpackChunkrc_virtual_list=self.webpackChunkrc_virtual_list||[]).push([[904],{23841:function(o,e,n){n.r(e),n.d(e,{demos:function(){return u}});var l=n(15009),s=n.n(l),a=n(99289),c=n.n(a),r=n(67294),p=n(52766),u={"docs-demo-animate-demo-animate":{component:r.memo(r.lazy(function(){return n.e(433).then(n.bind(n,24092))})),asset:{type:"BLOCK",id:"docs-demo-animate-demo-animate",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:n(25992).Z},react:{type:"NPM",value:"16.14.0"},"rc-animate":{type:"NPM",value:"2.11.1"},classnames:{type:"NPM",value:"2.5.1"},"rc-util":{type:"NPM",value:"5.43.0"},"./animate.less":{type:"FILE",value:n(48537).Z},"../src/List.tsx":{type:"FILE",value:n(19474).Z},"rc-resize-observer":{type:"NPM",value:"1.4.0"},"react-dom":{type:"NPM",value:"16.14.0"},"./hooks/useFrameWheel.ts":{type:"FILE",value:n(73706).Z},"./utils/scrollbarUtil.ts":{type:"FILE",value:n(17579).Z},"./Filler.tsx":{type:"FILE",value:n(24282).Z},"./hooks/useGetSize.ts":{type:"FILE",value:n(43021).Z},"./hooks/useOriginScroll.ts":{type:"FILE",value:n(76529).Z},"./hooks/useChildren.tsx":{type:"FILE",value:n(86857).Z},"./hooks/useDiffItem.ts":{type:"FILE",value:n(23709).Z},"./hooks/useScrollTo.tsx":{type:"FILE",value:n(23257).Z},"./ScrollBar.tsx":{type:"FILE",value:n(14409).Z},"./hooks/useHeights.tsx":{type:"FILE",value:n(32655).Z},"./hooks/useMobileTouchMove.ts":{type:"FILE",value:n(97846).Z},"../utils/algorithmUtil.ts":{type:"FILE",value:n(9290).Z},"../Item.tsx":{type:"FILE",value:n(58208).Z},"../utils/CacheMap.ts":{type:"FILE",value:n(40857).Z},"../utils/isFirefox.ts":{type:"FILE",value:n(70485).Z}},entry:"index.tsx"},context:{react:n(67294),"rc-animate/lib/CSSMotion":n(45916),classnames:n(93967),"rc-util/lib/hooks/useLayoutEffect":n(82546),"./animate.less":n(44462),"../src/List.tsx":n(20417),"rc-resize-observer":n(9220),"rc-util":n(28707),"react-dom":n(73935),"./hooks/useFrameWheel.ts":n(88562),"./utils/scrollbarUtil.ts":n(81543),"./Filler.tsx":n(87631),"./hooks/useGetSize.ts":n(8567),"./hooks/useOriginScroll.ts":n(40285),"./hooks/useChildren.tsx":n(314),"./hooks/useDiffItem.ts":n(42462),"./hooks/useScrollTo.tsx":n(16021),"./ScrollBar.tsx":n(95855),"./hooks/useHeights.tsx":n(50373),"./hooks/useMobileTouchMove.ts":n(31543),"rc-util/lib/raf":n(64543),"rc-util/lib/Dom/findDOMNode":n(35684),"../utils/algorithmUtil.ts":n(90120),"../Item.tsx":n(56379),"../utils/CacheMap.ts":n(11717),"../utils/isFirefox.ts":n(58998)},renderOpts:{compile:function(){var f=c()(s()().mark(function m(){var i,h=arguments;return s()().wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,n.e(335).then(n.bind(n,37335));case 2:return t.abrupt("return",(i=t.sent).default.apply(i,h));case 3:case"end":return t.stop()}},m)}));function d(){return f.apply(this,arguments)}return d}()}}}},33147:function(o,e,n){n.r(e),n.d(e,{demos:function(){return u}});var l=n(15009),s=n.n(l),a=n(99289),c=n.n(a),r=n(67294),p=n(81935),u={"docs-demo-basic-demo-basic":{component:r.memo(r.lazy(function(){return n.e(433).then(n.bind(n,34761))})),asset:{type:"BLOCK",id:"docs-demo-basic-demo-basic",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:n(37050).Z},react:{type:"NPM",value:"16.14.0"},"./basic.less":{type:"FILE",value:n(78376).Z},"../src/List.tsx":{type:"FILE",value:n(19474).Z},classnames:{type:"NPM",value:"2.5.1"},"rc-resize-observer":{type:"NPM",value:"1.4.0"},"rc-util":{type:"NPM",value:"5.43.0"},"react-dom":{type:"NPM",value:"16.14.0"},"./utils/scrollbarUtil.ts":{type:"FILE",value:n(17579).Z},"./hooks/useGetSize.ts":{type:"FILE",value:n(43021).Z},"./hooks/useOriginScroll.ts":{type:"FILE",value:n(76529).Z},"./hooks/useHeights.tsx":{type:"FILE",value:n(32655).Z},"./Filler.tsx":{type:"FILE",value:n(24282).Z},"./hooks/useScrollTo.tsx":{type:"FILE",value:n(23257).Z},"./hooks/useMobileTouchMove.ts":{type:"FILE",value:n(97846).Z},"./hooks/useChildren.tsx":{type:"FILE",value:n(86857).Z},"./ScrollBar.tsx":{type:"FILE",value:n(14409).Z},"./hooks/useDiffItem.ts":{type:"FILE",value:n(23709).Z},"./hooks/useFrameWheel.ts":{type:"FILE",value:n(73706).Z},"../Item.tsx":{type:"FILE",value:n(58208).Z},"../utils/algorithmUtil.ts":{type:"FILE",value:n(9290).Z},"../utils/CacheMap.ts":{type:"FILE",value:n(40857).Z},"../utils/isFirefox.ts":{type:"FILE",value:n(70485).Z}},entry:"index.tsx"},context:{react:n(67294),"./basic.less":n(50296),"../src/List.tsx":n(20417),classnames:n(93967),"rc-resize-observer":n(9220),"rc-util":n(28707),"rc-util/lib/hooks/useLayoutEffect":n(82546),"react-dom":n(73935),"./utils/scrollbarUtil.ts":n(81543),"./hooks/useGetSize.ts":n(8567),"./hooks/useOriginScroll.ts":n(40285),"./hooks/useHeights.tsx":n(50373),"./Filler.tsx":n(87631),"./hooks/useScrollTo.tsx":n(16021),"./hooks/useMobileTouchMove.ts":n(31543),"./hooks/useChildren.tsx":n(314),"./ScrollBar.tsx":n(95855),"./hooks/useDiffItem.ts":n(42462),"./hooks/useFrameWheel.ts":n(88562),"rc-util/lib/raf":n(64543),"rc-util/lib/Dom/findDOMNode":n(35684),"../Item.tsx":n(56379),"../utils/algorithmUtil.ts":n(90120),"../utils/CacheMap.ts":n(11717),"../utils/isFirefox.ts":n(58998)},renderOpts:{compile:function(){var f=c()(s()().mark(function m(){var i,h=arguments;return s()().wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,n.e(335).then(n.bind(n,37335));case 2:return t.abrupt("return",(i=t.sent).default.apply(i,h));case 3:case"end":return t.stop()}},m)}));function d(){return f.apply(this,arguments)}return d}()}}}},39319:function(o,e,n){n.r(e),n.d(e,{demos:function(){return u}});var l=n(15009),s=n.n(l),a=n(99289),c=n.n(a),r=n(67294),p=n(69196),u={"docs-demo-height-demo-height":{component:r.memo(r.lazy(function(){return n.e(433).then(n.bind(n,69258))})),asset:{type:"BLOCK",id:"docs-demo-height-demo-height",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:n(69400).Z},react:{type:"NPM",value:"16.14.0"},"../src/List.tsx":{type:"FILE",value:n(19474).Z},classnames:{type:"NPM",value:"2.5.1"},"rc-resize-observer":{type:"NPM",value:"1.4.0"},"rc-util":{type:"NPM",value:"5.43.0"},"react-dom":{type:"NPM",value:"16.14.0"},"./Filler.tsx":{type:"FILE",value:n(24282).Z},"./hooks/useDiffItem.ts":{type:"FILE",value:n(23709).Z},"./hooks/useHeights.tsx":{type:"FILE",value:n(32655).Z},"./hooks/useChildren.tsx":{type:"FILE",value:n(86857).Z},"./utils/scrollbarUtil.ts":{type:"FILE",value:n(17579).Z},"./hooks/useFrameWheel.ts":{type:"FILE",value:n(73706).Z},"./hooks/useGetSize.ts":{type:"FILE",value:n(43021).Z},"./hooks/useScrollTo.tsx":{type:"FILE",value:n(23257).Z},"./hooks/useMobileTouchMove.ts":{type:"FILE",value:n(97846).Z},"./ScrollBar.tsx":{type:"FILE",value:n(14409).Z},"./hooks/useOriginScroll.ts":{type:"FILE",value:n(76529).Z},"../utils/algorithmUtil.ts":{type:"FILE",value:n(9290).Z},"../Item.tsx":{type:"FILE",value:n(58208).Z},"../utils/CacheMap.ts":{type:"FILE",value:n(40857).Z},"../utils/isFirefox.ts":{type:"FILE",value:n(70485).Z}},entry:"index.tsx"},context:{react:n(67294),"../src/List.tsx":n(20417),classnames:n(93967),"rc-resize-observer":n(9220),"rc-util":n(28707),"rc-util/lib/hooks/useLayoutEffect":n(82546),"react-dom":n(73935),"./Filler.tsx":n(87631),"./hooks/useDiffItem.ts":n(42462),"./hooks/useHeights.tsx":n(50373),"./hooks/useChildren.tsx":n(314),"./utils/scrollbarUtil.ts":n(81543),"./hooks/useFrameWheel.ts":n(88562),"./hooks/useGetSize.ts":n(8567),"./hooks/useScrollTo.tsx":n(16021),"./hooks/useMobileTouchMove.ts":n(31543),"./ScrollBar.tsx":n(95855),"./hooks/useOriginScroll.ts":n(40285),"rc-util/lib/raf":n(64543),"rc-util/lib/Dom/findDOMNode":n(35684),"../utils/algorithmUtil.ts":n(90120),"../Item.tsx":n(56379),"../utils/CacheMap.ts":n(11717),"../utils/isFirefox.ts":n(58998)},renderOpts:{compile:function(){var f=c()(s()().mark(function m(){var i,h=arguments;return s()().wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,n.e(335).then(n.bind(n,37335));case 2:return t.abrupt("return",(i=t.sent).default.apply(i,h));case 3:case"end":return t.stop()}},m)}));function d(){return f.apply(this,arguments)}return d}()}}}},21380:function(o,e,n){n.r(e),n.d(e,{demos:function(){return u}});var l=n(15009),s=n.n(l),a=n(99289),c=n.n(a),r=n(67294),p=n(38978),u={"docs-demo-horizontal-scroll-demo-horizontal-scroll":{component:r.memo(r.lazy(function(){return n.e(433).then(n.bind(n,2739))})),asset:{type:"BLOCK",id:"docs-demo-horizontal-scroll-demo-horizontal-scroll",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:n(12803).Z},react:{type:"NPM",value:"16.14.0"},"../src/List.tsx":{type:"FILE",value:n(19474).Z},classnames:{type:"NPM",value:"2.5.1"},"rc-resize-observer":{type:"NPM",value:"1.4.0"},"rc-util":{type:"NPM",value:"5.43.0"},"react-dom":{type:"NPM",value:"16.14.0"},"./Filler.tsx":{type:"FILE",value:n(24282).Z},"./hooks/useFrameWheel.ts":{type:"FILE",value:n(73706).Z},"./hooks/useChildren.tsx":{type:"FILE",value:n(86857).Z},"./utils/scrollbarUtil.ts":{type:"FILE",value:n(17579).Z},"./hooks/useDiffItem.ts":{type:"FILE",value:n(23709).Z},"./hooks/useGetSize.ts":{type:"FILE",value:n(43021).Z},"./hooks/useOriginScroll.ts":{type:"FILE",value:n(76529).Z},"./hooks/useHeights.tsx":{type:"FILE",value:n(32655).Z},"./hooks/useMobileTouchMove.ts":{type:"FILE",value:n(97846).Z},"./hooks/useScrollTo.tsx":{type:"FILE",value:n(23257).Z},"./ScrollBar.tsx":{type:"FILE",value:n(14409).Z},"../Item.tsx":{type:"FILE",value:n(58208).Z},"../utils/algorithmUtil.ts":{type:"FILE",value:n(9290).Z},"../utils/CacheMap.ts":{type:"FILE",value:n(40857).Z},"../utils/isFirefox.ts":{type:"FILE",value:n(70485).Z}},entry:"index.tsx"},context:{react:n(67294),"../src/List.tsx":n(20417),classnames:n(93967),"rc-resize-observer":n(9220),"rc-util":n(28707),"rc-util/lib/hooks/useLayoutEffect":n(82546),"react-dom":n(73935),"./Filler.tsx":n(87631),"./hooks/useFrameWheel.ts":n(88562),"./hooks/useChildren.tsx":n(314),"./utils/scrollbarUtil.ts":n(81543),"./hooks/useDiffItem.ts":n(42462),"./hooks/useGetSize.ts":n(8567),"./hooks/useOriginScroll.ts":n(40285),"./hooks/useHeights.tsx":n(50373),"./hooks/useMobileTouchMove.ts":n(31543),"./hooks/useScrollTo.tsx":n(16021),"./ScrollBar.tsx":n(95855),"rc-util/lib/raf":n(64543),"rc-util/lib/Dom/findDOMNode":n(35684),"../Item.tsx":n(56379),"../utils/algorithmUtil.ts":n(90120),"../utils/CacheMap.ts":n(11717),"../utils/isFirefox.ts":n(58998)},renderOpts:{compile:function(){var f=c()(s()().mark(function m(){var i,h=arguments;return s()().wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,n.e(335).then(n.bind(n,37335));case 2:return t.abrupt("return",(i=t.sent).default.apply(i,h));case 3:case"end":return t.stop()}},m)}));function d(){return f.apply(this,arguments)}return d}()}}}},57369:function(o,e,n){n.r(e),n.d(e,{demos:function(){return u}});var l=n(15009),s=n.n(l),a=n(99289),c=n.n(a),r=n(67294),p=n(35721),u={"docs-demo-no-virtual-demo-no-virtual":{component:r.memo(r.lazy(function(){return n.e(433).then(n.bind(n,62835))})),asset:{type:"BLOCK",id:"docs-demo-no-virtual-demo-no-virtual",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:n(81969).Z},react:{type:"NPM",value:"16.14.0"},"../src/List.tsx":{type:"FILE",value:n(19474).Z},classnames:{type:"NPM",value:"2.5.1"},"rc-resize-observer":{type:"NPM",value:"1.4.0"},"rc-util":{type:"NPM",value:"5.43.0"},"react-dom":{type:"NPM",value:"16.14.0"},"./Filler.tsx":{type:"FILE",value:n(24282).Z},"./hooks/useFrameWheel.ts":{type:"FILE",value:n(73706).Z},"./utils/scrollbarUtil.ts":{type:"FILE",value:n(17579).Z},"./hooks/useDiffItem.ts":{type:"FILE",value:n(23709).Z},"./hooks/useOriginScroll.ts":{type:"FILE",value:n(76529).Z},"./ScrollBar.tsx":{type:"FILE",value:n(14409).Z},"./hooks/useChildren.tsx":{type:"FILE",value:n(86857).Z},"./hooks/useGetSize.ts":{type:"FILE",value:n(43021).Z},"./hooks/useHeights.tsx":{type:"FILE",value:n(32655).Z},"./hooks/useScrollTo.tsx":{type:"FILE",value:n(23257).Z},"./hooks/useMobileTouchMove.ts":{type:"FILE",value:n(97846).Z},"../utils/algorithmUtil.ts":{type:"FILE",value:n(9290).Z},"../Item.tsx":{type:"FILE",value:n(58208).Z},"../utils/isFirefox.ts":{type:"FILE",value:n(70485).Z},"../utils/CacheMap.ts":{type:"FILE",value:n(40857).Z}},entry:"index.tsx"},context:{react:n(67294),"../src/List.tsx":n(20417),classnames:n(93967),"rc-resize-observer":n(9220),"rc-util":n(28707),"rc-util/lib/hooks/useLayoutEffect":n(82546),"react-dom":n(73935),"./Filler.tsx":n(87631),"./hooks/useFrameWheel.ts":n(88562),"./utils/scrollbarUtil.ts":n(81543),"./hooks/useDiffItem.ts":n(42462),"./hooks/useOriginScroll.ts":n(40285),"./ScrollBar.tsx":n(95855),"./hooks/useChildren.tsx":n(314),"./hooks/useGetSize.ts":n(8567),"./hooks/useHeights.tsx":n(50373),"./hooks/useScrollTo.tsx":n(16021),"./hooks/useMobileTouchMove.ts":n(31543),"rc-util/lib/raf":n(64543),"rc-util/lib/Dom/findDOMNode":n(35684),"../utils/algorithmUtil.ts":n(90120),"../Item.tsx":n(56379),"../utils/isFirefox.ts":n(58998),"../utils/CacheMap.ts":n(11717)},renderOpts:{compile:function(){var f=c()(s()().mark(function m(){var i,h=arguments;return s()().wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,n.e(335).then(n.bind(n,37335));case 2:return t.abrupt("return",(i=t.sent).default.apply(i,h));case 3:case"end":return t.stop()}},m)}));function d(){return f.apply(this,arguments)}return d}()}}}},83476:function(o,e,n){n.r(e),n.d(e,{demos:function(){return u}});var l=n(15009),s=n.n(l),a=n(99289),c=n.n(a),r=n(67294),p=n(74430),u={"docs-demo-switch-demo-switch":{component:r.memo(r.lazy(function(){return n.e(433).then(n.bind(n,94936))})),asset:{type:"BLOCK",id:"docs-demo-switch-demo-switch",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:n(80176).Z},react:{type:"NPM",value:"16.14.0"},"../src/List.tsx":{type:"FILE",value:n(19474).Z},classnames:{type:"NPM",value:"2.5.1"},"rc-resize-observer":{type:"NPM",value:"1.4.0"},"rc-util":{type:"NPM",value:"5.43.0"},"react-dom":{type:"NPM",value:"16.14.0"},"./hooks/useDiffItem.ts":{type:"FILE",value:n(23709).Z},"./Filler.tsx":{type:"FILE",value:n(24282).Z},"./utils/scrollbarUtil.ts":{type:"FILE",value:n(17579).Z},"./hooks/useChildren.tsx":{type:"FILE",value:n(86857).Z},"./hooks/useFrameWheel.ts":{type:"FILE",value:n(73706).Z},"./hooks/useMobileTouchMove.ts":{type:"FILE",value:n(97846).Z},"./hooks/useOriginScroll.ts":{type:"FILE",value:n(76529).Z},"./hooks/useScrollTo.tsx":{type:"FILE",value:n(23257).Z},"./hooks/useGetSize.ts":{type:"FILE",value:n(43021).Z},"./ScrollBar.tsx":{type:"FILE",value:n(14409).Z},"./hooks/useHeights.tsx":{type:"FILE",value:n(32655).Z},"../utils/algorithmUtil.ts":{type:"FILE",value:n(9290).Z},"../Item.tsx":{type:"FILE",value:n(58208).Z},"../utils/isFirefox.ts":{type:"FILE",value:n(70485).Z},"../utils/CacheMap.ts":{type:"FILE",value:n(40857).Z}},entry:"index.tsx"},context:{react:n(67294),"../src/List.tsx":n(20417),classnames:n(93967),"rc-resize-observer":n(9220),"rc-util":n(28707),"rc-util/lib/hooks/useLayoutEffect":n(82546),"react-dom":n(73935),"./hooks/useDiffItem.ts":n(42462),"./Filler.tsx":n(87631),"./utils/scrollbarUtil.ts":n(81543),"./hooks/useChildren.tsx":n(314),"./hooks/useFrameWheel.ts":n(88562),"./hooks/useMobileTouchMove.ts":n(31543),"./hooks/useOriginScroll.ts":n(40285),"./hooks/useScrollTo.tsx":n(16021),"./hooks/useGetSize.ts":n(8567),"./ScrollBar.tsx":n(95855),"./hooks/useHeights.tsx":n(50373),"rc-util/lib/raf":n(64543),"rc-util/lib/Dom/findDOMNode":n(35684),"../utils/algorithmUtil.ts":n(90120),"../Item.tsx":n(56379),"../utils/isFirefox.ts":n(58998),"../utils/CacheMap.ts":n(11717)},renderOpts:{compile:function(){var f=c()(s()().mark(function m(){var i,h=arguments;return s()().wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,n.e(335).then(n.bind(n,37335));case 2:return t.abrupt("return",(i=t.sent).default.apply(i,h));case 3:case"end":return t.stop()}},m)}));function d(){return f.apply(this,arguments)}return d}()}}}},11171:function(o,e,n){n.r(e),n.d(e,{demos:function(){return a}});var l=n(67294),s=n(68537),a={}},44462:function(o,e,n){n.r(e)},50296:function(o,e,n){n.r(e)},84473:function(o,e,n){n.r(e),n.d(e,{texts:function(){return s}});var l=n(52766);const s=[]},55469:function(o,e,n){n.r(e),n.d(e,{texts:function(){return s}});var l=n(81935);const s=[]},46020:function(o,e,n){n.r(e),n.d(e,{texts:function(){return s}});var l=n(69196);const s=[]},84360:function(o,e,n){n.r(e),n.d(e,{texts:function(){return s}});var l=n(38978);const s=[]},95903:function(o,e,n){n.r(e),n.d(e,{texts:function(){return s}});var l=n(35721);const s=[]},22314:function(o,e,n){n.r(e),n.d(e,{texts:function(){return s}});var l=n(74430);const s=[]},51446:function(o,e,n){n.r(e),n.d(e,{texts:function(){return s}});var l=n(68537);const s=[{value:"React Virtual List Component which worked with animation.",paraId:0,tocIndex:0},{value:" ",paraId:1,tocIndex:0},{value:" ",paraId:1,tocIndex:0},{value:" ",paraId:1,tocIndex:0},{value:" ",paraId:1,tocIndex:0},{value:" ",paraId:1,tocIndex:0},{value:"https://virtual-list-react-component.vercel.app/",paraId:2,tocIndex:1},{value:`npm install
npm start
open http://localhost:9001/
`,paraId:3,tocIndex:2},{value:"Support react.js",paraId:4,tocIndex:3},{value:"Support animation",paraId:4,tocIndex:3},{value:"Support IE11+",paraId:4,tocIndex:3},{value:`import List from 'rc-virtual-list';

<List data={[0, 1, 2]} height={200} itemHeight={30} itemKey="id">
  {index => <div>{index}</div>}
</List>;
`,paraId:5,tocIndex:5},{value:"Prop",paraId:6,tocIndex:7},{value:"Description",paraId:6,tocIndex:7},{value:"Type",paraId:6,tocIndex:7},{value:"Default",paraId:6,tocIndex:7},{value:"children",paraId:6,tocIndex:7},{value:"Render props of item",paraId:6,tocIndex:7},{value:"(item, index, props) => ReactElement",paraId:6,tocIndex:7},{value:"-",paraId:6,tocIndex:7},{value:"component",paraId:6,tocIndex:7},{value:"Customize List dom element",paraId:6,tocIndex:7},{value:"string | Component",paraId:6,tocIndex:7},{value:"div",paraId:6,tocIndex:7},{value:"data",paraId:6,tocIndex:7},{value:"Data list",paraId:6,tocIndex:7},{value:"Array",paraId:6,tocIndex:7},{value:"-",paraId:6,tocIndex:7},{value:"disabled",paraId:6,tocIndex:7},{value:"Disable scroll check. Usually used on animation control",paraId:6,tocIndex:7},{value:"boolean",paraId:6,tocIndex:7},{value:"false",paraId:6,tocIndex:7},{value:"height",paraId:6,tocIndex:7},{value:"List height",paraId:6,tocIndex:7},{value:"number",paraId:6,tocIndex:7},{value:"-",paraId:6,tocIndex:7},{value:"itemHeight",paraId:6,tocIndex:7},{value:"Item minium height",paraId:6,tocIndex:7},{value:"number",paraId:6,tocIndex:7},{value:"-",paraId:6,tocIndex:7},{value:"itemKey",paraId:6,tocIndex:7},{value:"Match key with item",paraId:6,tocIndex:7},{value:"string",paraId:6,tocIndex:7},{value:"-",paraId:6,tocIndex:7},{value:"styles",paraId:6,tocIndex:7},{value:"style",paraId:6,tocIndex:7},{value:"{ horizontalScrollBar?: React.CSSProperties; horizontalScrollBarThumb?: React.CSSProperties; verticalScrollBar?: React.CSSProperties; verticalScrollBarThumb?: React.CSSProperties; }",paraId:6,tocIndex:7},{value:"-",paraId:6,tocIndex:7},{value:"children",paraId:7,tocIndex:7},{value:" provides additional ",paraId:7,tocIndex:7},{value:"props",paraId:7,tocIndex:7},{value:` argument to support IE 11 scroll shaking.
It will set `,paraId:7,tocIndex:7},{value:"style",paraId:7,tocIndex:7},{value:" to ",paraId:7,tocIndex:7},{value:"visibility: hidden",paraId:7,tocIndex:7},{value:" when measuring. You can ignore this if no requirement on IE.",paraId:7,tocIndex:7}]},48537:function(o,e){e.Z=`.motion {
  transition: all 0.3s;
}

.item {
  display: inline-block;
  box-sizing: border-box;
  margin: 0;
  padding: 0 16px;
  overflow: hidden;
  line-height: 31px;
  position: relative;

  &:hover {
    background: rgba(255, 0, 0, 0.1);
  }

  &::after {
    content: '';
    border-bottom: 1px solid gray;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
  }

  button {
    vertical-align: text-top;
    margin-right: 8px;
  }
}
`},25992:function(o,e){e.Z=`/* eslint-disable arrow-body-style */

import * as React from 'react';
// @ts-ignore
import CSSMotion from 'rc-animate/lib/CSSMotion';
import classNames from 'classnames';
import List, { ListRef } from '../src/List';
import useLayoutEffect from 'rc-util/lib/hooks/useLayoutEffect';
import './animate.less';

let uuid = 0;
function genItem() {
  const item = {
    id: \`key_\${uuid}\`,
    uuid,
  };
  uuid += 1;
  return item;
}

const originData: Item[] = [];
for (let i = 0; i < 1000; i += 1) {
  originData.push(genItem());
}

interface Item {
  id: string;
  uuid: number;
}

interface MyItemProps extends Item {
  visible: boolean;
  motionAppear: boolean;
  onClose: (id: string) => void;
  onLeave: (id: string) => void;
  onAppear: (...args: any[]) => void;
  onInsertBefore: (id: string) => void;
  onInsertAfter: (id: string) => void;
}

const getCurrentHeight = (node: HTMLElement) => ({ height: node.offsetHeight });
const getMaxHeight = (node: HTMLElement) => {
  return { height: node.scrollHeight };
};
const getCollapsedHeight = () => ({ height: 0, opacity: 0 });

const MyItem: React.ForwardRefRenderFunction<any, MyItemProps> = (
  {
    id,
    uuid: itemUuid,
    visible,
    onClose,
    onLeave,
    onAppear,
    onInsertBefore,
    onInsertAfter,
    motionAppear,
  },
  ref,
) => {
  const motionRef = React.useRef(false);
  useLayoutEffect(() => {
    return () => {
      if (motionRef.current) {
        onAppear();
      }
    };
  }, []);

  return (
    <CSSMotion
      visible={visible}
      ref={ref}
      motionName="motion"
      motionAppear={motionAppear}
      onAppearStart={getCollapsedHeight}
      onAppearActive={node => {
        motionRef.current = true;
        return getMaxHeight(node);
      }}
      onAppearEnd={onAppear}
      onLeaveStart={getCurrentHeight}
      onLeaveActive={getCollapsedHeight}
      onLeaveEnd={() => {
        onLeave(id);
      }}
    >
      {({ className, style }, passedMotionRef) => {
        return (
          <div
            ref={passedMotionRef}
            className={classNames('item', className)}
            style={style}
            data-id={id}
          >
            <div style={{ height: itemUuid % 2 ? 100 : undefined }}>
              <button
                type="button"
                onClick={() => {
                  onClose(id);
                }}
              >
                Close
              </button>
              <button
                type="button"
                onClick={() => {
                  onInsertBefore(id);
                }}
              >
                Insert Before
              </button>
              <button
                type="button"
                onClick={() => {
                  onInsertAfter(id);
                }}
              >
                Insert After
              </button>
              {id}
            </div>
          </div>
        );
      }}
    </CSSMotion>
  );
};

const ForwardMyItem = React.forwardRef(MyItem);

const Demo = () => {
  const [data, setData] = React.useState(originData);
  const [closeMap, setCloseMap] = React.useState<{ [id: number]: boolean }>({});
  const [animating, setAnimating] = React.useState(false);
  const [insertIndex, setInsertIndex] = React.useState<number>();

  const listRef = React.useRef<ListRef>();

  const onClose = (id: string) => {
    setCloseMap({
      ...closeMap,
      [id]: true,
    });
  };

  const onLeave = (id: string) => {
    const newData = data.filter(item => item.id !== id);
    setData(newData);
  };

  const onAppear = (...args: any[]) => {
    console.log('Appear:', args);
    setAnimating(false);
  };

  function lockForAnimation() {
    setAnimating(true);
  }

  const onInsertBefore = (id: string) => {
    const index = data.findIndex(item => item.id === id);
    const newData = [...data.slice(0, index), genItem(), ...data.slice(index)];
    setInsertIndex(index);
    setData(newData);
    lockForAnimation();
  };
  const onInsertAfter = (id: string) => {
    const index = data.findIndex(item => item.id === id) + 1;
    const newData = [...data.slice(0, index), genItem(), ...data.slice(index)];
    setInsertIndex(index);
    setData(newData);
    lockForAnimation();
  };

  return (
    <React.StrictMode>
      <div>
        <h2>Animate</h2>
        <p>Current: {data.length} records</p>

        <List<Item>
          data={data}
          data-id="list"
          height={200}
          itemHeight={20}
          itemKey="id"
          // disabled={animating}
          ref={listRef}
          style={{
            border: '1px solid red',
            boxSizing: 'border-box',
          }}
          // onSkipRender={onAppear}
          // onItemRemove={onAppear}
        >
          {(item, index) => (
            <ForwardMyItem
              {...item}
              motionAppear={animating && insertIndex === index}
              visible={!closeMap[item.id]}
              onClose={onClose}
              onLeave={onLeave}
              onAppear={onAppear}
              onInsertBefore={onInsertBefore}
              onInsertAfter={onInsertAfter}
            />
          )}
        </List>
      </div>
    </React.StrictMode>
  );
};

export default Demo;
`},78376:function(o,e){e.Z=`.fixed-item {
  border: 1px solid gray;
  padding: 0 16px;
  height: 32px;
  line-height: 30px;
  box-sizing: border-box;
  display: inline-block;
}
`},37050:function(o,e){e.Z=`import * as React from 'react';
import List, { type ListRef } from '../src/List';
import './basic.less';

interface Item {
  id: number;
}

const MyItem: React.ForwardRefRenderFunction<any, Item> = ({ id }, ref) => (
  <span
    ref={ref}
    style={{
      height: 30 + (id % 2 ? 0 : 10),
    }}
    className="fixed-item"
    onClick={() => {
      console.log('Click:', id);
    }}
  >
    {id}
  </span>
);

const ForwardMyItem = React.forwardRef(MyItem);

class TestItem extends React.Component<Item, {}> {
  state = {};

  render() {
    return <div style={{ lineHeight: '30px' }}>{this.props.id}</div>;
  }
}

const data: Item[] = [];
for (let i = 0; i < 1000; i += 1) {
  data.push({
    id: i,
  });
}

const TYPES = [
  { name: 'ref real dom element', type: 'dom', component: ForwardMyItem },
  { name: 'ref react node', type: 'react', component: TestItem },
];

const onScroll: React.UIEventHandler<HTMLElement> = (e) => {
  console.log('scroll:', e.currentTarget.scrollTop);
};

const Demo = () => {
  const [destroy, setDestroy] = React.useState(false);
  const [visible, setVisible] = React.useState(true);
  const [type, setType] = React.useState('dom');
  const listRef = React.useRef<ListRef>(null);

  return (
    <React.StrictMode>
      <div style={{ height: '200vh' }}>
        <h2>Basic</h2>
        {TYPES.map(({ name, type: nType }) => (
          <label key={nType}>
            <input
              name="type"
              type="radio"
              checked={type === nType}
              onChange={() => {
                setType(nType);
              }}
            />
            {name}
          </label>
        ))}

        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo(null);
          }}
        >
          Show scroll bar
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo(500);
          }}
        >
          Scroll To 100px
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 99999999,
              align: 'top',
            });
          }}
        >
          Scroll To 99999999 (top)
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 50,
              align: 'top',
            });
          }}
        >
          Scroll To 50 (top)
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 50,
              align: 'bottom',
            });
          }}
        >
          Scroll To 50 (bottom)
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 50,
              align: 'auto',
            });
          }}
        >
          Scroll To 50 (auto)
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 50,
              align: 'top',
              offset: 15,
            });
          }}
        >
          Scroll To 50 (top) + 15 offset
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 50,
              align: 'bottom',
              offset: 15,
            });
          }}
        >
          Scroll To 50 (bottom) + 15 offset
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              key: 50,
              align: 'auto',
            });
          }}
        >
          Scroll To key 50 (auto)
        </button>

        <button
          type="button"
          onClick={() => {
            setVisible((v) => !v);
          }}
        >
          visible
        </button>

        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: data.length - 2,
              align: 'top',
            });
          }}
        >
          Scroll To Last (top)
        </button>
        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 0,
              align: 'bottom',
            });
          }}
        >
          Scroll To First (bottom)
        </button>

        <button
          type="button"
          onClick={() => {
            listRef.current.scrollTo({
              index: 50,
              align: 'top',
            });
            setDestroy(true);
          }}
        >
          Scroll To remove
        </button>

        {!destroy && (
          <List
            id="list"
            ref={listRef}
            data={data}
            height={200}
            itemHeight={20}
            itemKey="id"
            style={{
              border: '1px solid red',
              boxSizing: 'border-box',
              display: visible ? null : 'none',
            }}
            onScroll={onScroll}
          >
            {(item, _, props) =>
              type === 'dom' ? (
                <ForwardMyItem {...item} {...props} />
              ) : (
                <TestItem {...item} {...props} />
              )
            }
          </List>
        )}
      </div>
    </React.StrictMode>
  );
};

export default Demo;

/* eslint-enable */
`},69400:function(o,e){e.Z=`import * as React from 'react';
import List from '../src/List';

interface Item {
  id: number;
  height: number;
}

const MyItem: React.ForwardRefRenderFunction<HTMLElement, Item> = ({ id, height }, ref) => {
  return (
    <span
      ref={ref}
      style={{
        border: '1px solid gray',
        padding: '0 16px',
        height,
        lineHeight: '30px',
        boxSizing: 'border-box',
        display: 'inline-block',
      }}
    >
      {id}
    </span>
  );
};

const ForwardMyItem = React.forwardRef(MyItem);

const data: Item[] = [];
for (let i = 0; i < 100; i += 1) {
  data.push({
    id: i,
    height: 30 + (i % 2 ? 70 : 0),
  });
}

const Demo = () => {
  return (
    <React.StrictMode>
      <div>
        <h2>Dynamic Height</h2>

        <List
          data={data}
          height={500}
          itemHeight={30}
          itemKey="id"
          style={{
            border: '1px solid red',
            boxSizing: 'border-box',
          }}
        >
          {item => <ForwardMyItem {...item} />}
        </List>
      </div>
    </React.StrictMode>
  );
};

export default Demo;
`},12803:function(o,e){e.Z=`import * as React from 'react';
import List from '../src/List';

interface Item {
  id: string;
  height: number;
}

const Rect = ({ style }: { style?: React.CSSProperties }) => (
  <div
    style={{
      position: 'sticky',
      top: 0,
      background: 'blue',
      flex: 'none',
      borderInline: \`1px solid red\`,
      zIndex: 2,
      ...style,
    }}
  >
    Hello
  </div>
);

const MyItem: React.ForwardRefRenderFunction<
  HTMLDivElement,
  Item & { style?: React.CSSProperties }
> = (props, ref) => {
  const { id, height, style } = props;

  return (
    <div
      ref={ref}
      style={{
        border: '1px solid gray',
        height,
        lineHeight: '30px',
        boxSizing: 'border-box',
        display: 'flex',
        // position: 'relative',
        alignItems: 'center',
        borderInline: 0,
        ...style,
      }}
    >
      <Rect
        style={{
          left: 0,
        }}
      />
      <div
        style={{
          flex: 'auto',
          minWidth: 0,
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
        }}
      >
        {id} {'longText '.repeat(100)}
      </div>
      <Rect
        style={{
          right: 0,
        }}
      />
    </div>
  );
};

const ForwardMyItem = React.forwardRef(MyItem);

function getData(count: number) {
  const data: Item[] = [];
  for (let i = 0; i < count; i += 1) {
    data.push({
      id: \`id_\${i}\`,
      height: Math.round(30 + Math.random() * 10),
    });
  }
  return data;
}

const Demo = () => {
  const [rtl, setRTL] = React.useState(false);
  const [count, setCount] = React.useState('1000');
  const [data, setData] = React.useState<Item[]>([]);

  React.useEffect(() => {
    const num = Number(count);
    if (!Number.isNaN(num)) {
      setData(getData(num));
    }
  }, [count]);

  return (
    <React.StrictMode>
      <div>
        <button
          onClick={() => {
            setRTL(!rtl);
          }}
        >
          RTL: {String(rtl)}
        </button>

        <input
          type="number"
          value={count}
          onChange={(e) => {
            const num = e.target.value;

            setCount(num);
          }}
        />

        <div style={{ width: 500, margin: 64 }}>
          <List
            fullHeight={false}
            direction={rtl ? 'rtl' : 'ltr'}
            data={data}
            height={300}
            itemHeight={30}
            itemKey="id"
            scrollWidth={2328}
            // scrollWidth={100}
            style={{
              border: '1px solid red',
              boxSizing: 'border-box',
            }}
            extraRender={(info) => {
              const { offsetY, rtl: isRTL } = info;
              const sizeInfo = info.getSize('id_5', 'id_10');

              return (
                <div
                  style={{
                    position: 'absolute',
                    top: -offsetY + sizeInfo.top,
                    height: sizeInfo.bottom - sizeInfo.top,
                    [isRTL ? 'right' : 'left']: 100,
                    background: 'rgba(255,0,0,0.9)',
                    zIndex: 1,
                  }}
                >
                  Extra
                </div>
              );
            }}
            onVirtualScroll={(e) => {
              // console.warn('Scroll:', e);
            }}
          >
            {(item, _, props) => <ForwardMyItem {...item} {...props} />}
          </List>
        </div>
      </div>
    </React.StrictMode>
  );
};

export default Demo;
`},81969:function(o,e){e.Z=`/* eslint-disable arrow-body-style */
import * as React from 'react';
import List from '../src/List';

interface Item {
  id: number;
  height: number;
}

const MyItem: React.FC<Item> = ({ id, height }, ref) => {
  return (
    <span
      ref={ref}
      style={{
        border: '1px solid gray',
        padding: '0 16px',
        height,
        lineHeight: '30px',
        boxSizing: 'border-box',
        display: 'inline-block',
      }}
    >
      {id}
    </span>
  );
};

const ForwardMyItem = React.forwardRef(MyItem as any);

const data: Item[] = [];
for (let i = 0; i < 100; i += 1) {
  data.push({
    id: i,
    height: 30 + (i % 2 ? 20 : 0),
  });
}

const Demo = () => {
  return (
    <React.StrictMode>
      <div>
        <h2>Not Data</h2>
        <List
          data={null}
          itemHeight={30}
          height={100}
          itemKey="id"
          style={{
            border: '1px solid red',
            boxSizing: 'border-box',
          }}
        >
          {item => <ForwardMyItem {...(item as any)} />}
        </List>

        <h2>Less Count</h2>
        <List
          data={data.slice(0, 1)}
          itemHeight={30}
          height={100}
          itemKey="id"
          style={{
            border: '1px solid red',
            boxSizing: 'border-box',
          }}
        >
          {item => <ForwardMyItem {...(item as any)} />}
        </List>

        <h2>Less Item Height</h2>
        <List
          data={data.slice(0, 10)}
          itemHeight={1}
          height={100}
          itemKey="id"
          style={{
            border: '1px solid red',
            boxSizing: 'border-box',
          }}
        >
          {item => <ForwardMyItem {...(item as any)} />}
        </List>

        <h2>Without Height</h2>
        <List
          data={data}
          itemHeight={30}
          itemKey="id"
          style={{
            border: '1px solid red',
            boxSizing: 'border-box',
          }}
        >
          {item => <ForwardMyItem {...(item as any)} />}
        </List>
      </div>
    </React.StrictMode>
  );
};

export default Demo;
`},80176:function(o,e){e.Z=`import * as React from 'react';
import type { ListRef } from '../src/List';
import List from '../src/List';

interface Item {
  id: number;
}

const MyItem: React.FC<Item> = ({ id }, ref) => (
  <span
    ref={ref}
    style={{
      border: '1px solid gray',
      padding: '0 16px',
      height: 30,
      lineHeight: '30px',
      boxSizing: 'border-box',
      display: 'inline-block',
    }}
  >
    {id}
  </span>
);

const ForwardMyItem = React.forwardRef(MyItem as any);

function getData(count: number) {
  const data: Item[] = [];
  for (let i = 0; i < count; i += 1) {
    data.push({
      id: i,
    });
  }
  return data;
}

const Demo = () => {
  const [height, setHeight] = React.useState(200);
  const [data, setData] = React.useState(getData(20));
  const [fullHeight, setFullHeight] = React.useState(true);
  const listRef = React.useRef<ListRef>();

  return (
    <React.StrictMode>
      <div style={{ height: '150vh' }}>
        <h2>Switch</h2>
        <span
          onChange={(e: any) => {
            setData(getData(Number(e.target.value)));
          }}
        >
          Data
          <label>
            <input type="radio" name="switch" value={0} />0
          </label>
          <label>
            <input type="radio" name="switch" value={2} />2
          </label>
          <label>
            <input type="radio" name="switch" value={20} />
            20
          </label>
          <label>
            <input type="radio" name="switch" value={100} />
            100
          </label>
          <label>
            <input type="radio" name="switch" value={200} />
            200
          </label>
          <label>
            <input type="radio" name="switch" value={1000} />
            1000
          </label>
          <button
            type="button"
            onClick={() => {
              listRef.current.scrollTo(null);
            }}
          >
            Show scrollbar
          </button>
        </span>
        <span
          onChange={(e: any) => {
            setHeight(Number(e.target.value));
          }}
        >
          | Height
          <label>
            <input type="radio" name="switch" value={0} />0
          </label>
          <label>
            <input type="radio" name="switch" value={100} />
            100
          </label>
          <label>
            <input type="radio" name="switch" value={200} />
            200
          </label>
        </span>
        <span>
          <button
            onClick={() => {
              setFullHeight(!fullHeight);
            }}
          >
            Full Height: {String(fullHeight)}
          </button>
        </span>

        <List
          ref={listRef}
          data={data}
          height={height}
          itemHeight={10}
          itemKey="id"
          fullHeight={fullHeight}
          style={{
            border: '1px solid red',
            boxSizing: 'border-box',
          }}
        >
          {(item, _, props) => <ForwardMyItem {...(item as any)} {...props} />}
        </List>
      </div>
    </React.StrictMode>
  );
};

export default Demo;
`},24282:function(o,e){e.Z=`import * as React from 'react';
import ResizeObserver from 'rc-resize-observer';
import classNames from 'classnames';

export type InnerProps = Pick<React.HTMLAttributes<HTMLDivElement>, 'role' | 'id'>;

interface FillerProps {
  prefixCls?: string;
  /** Virtual filler height. Should be \`count * itemMinHeight\` */
  height: number;
  /** Set offset of visible items. Should be the top of start item position */
  offsetY?: number;
  offsetX?: number;

  scrollWidth?: number;

  children: React.ReactNode;

  onInnerResize?: () => void;

  innerProps?: InnerProps;

  rtl: boolean;

  extra?: React.ReactNode;
}

/**
 * Fill component to provided the scroll content real height.
 */
const Filler = React.forwardRef(
  (
    {
      height,
      offsetY,
      offsetX,
      children,
      prefixCls,
      onInnerResize,
      innerProps,
      rtl,
      extra,
    }: FillerProps,
    ref: React.Ref<HTMLDivElement>,
  ) => {
    let outerStyle: React.CSSProperties = {};

    let innerStyle: React.CSSProperties = {
      display: 'flex',
      flexDirection: 'column',
    };

    if (offsetY !== undefined) {
      // Not set \`width\` since this will break \`sticky: right\`
      outerStyle = {
        height,
        position: 'relative',
        overflow: 'hidden',
      };

      innerStyle = {
        ...innerStyle,
        transform: \`translateY(\${offsetY}px)\`,
        [rtl ? 'marginRight' : 'marginLeft']: -offsetX,
        position: 'absolute',
        left: 0,
        right: 0,
        top: 0,
      };
    }

    return (
      <div style={outerStyle}>
        <ResizeObserver
          onResize={({ offsetHeight }) => {
            if (offsetHeight && onInnerResize) {
              onInnerResize();
            }
          }}
        >
          <div
            style={innerStyle}
            className={classNames({
              [\`\${prefixCls}-holder-inner\`]: prefixCls,
            })}
            ref={ref}
            {...innerProps}
          >
            {children}
            {extra}
          </div>
        </ResizeObserver>
      </div>
    );
  },
);

Filler.displayName = 'Filler';

export default Filler;
`},58208:function(o,e){e.Z=`import * as React from 'react';

export interface ItemProps {
  children: React.ReactElement;
  setRef: (element: HTMLElement) => void;
}

export function Item({ children, setRef }: ItemProps) {
  const refFunc = React.useCallback(node => {
    setRef(node);
  }, []);

  return React.cloneElement(children, {
    ref: refFunc,
  });
}
`},19474:function(o,e){e.Z=`import classNames from 'classnames';
import type { ResizeObserverProps } from 'rc-resize-observer';
import ResizeObserver from 'rc-resize-observer';
import { useEvent } from 'rc-util';
import useLayoutEffect from 'rc-util/lib/hooks/useLayoutEffect';
import * as React from 'react';
import { useRef, useState } from 'react';
import { flushSync } from 'react-dom';
import type { InnerProps } from './Filler';
import Filler from './Filler';
import useChildren from './hooks/useChildren';
import useDiffItem from './hooks/useDiffItem';
import useFrameWheel from './hooks/useFrameWheel';
import { useGetSize } from './hooks/useGetSize';
import useHeights from './hooks/useHeights';
import useMobileTouchMove from './hooks/useMobileTouchMove';
import useOriginScroll from './hooks/useOriginScroll';
import type { ScrollPos, ScrollTarget } from './hooks/useScrollTo';
import useScrollTo from './hooks/useScrollTo';
import type { ExtraRenderInfo, GetKey, RenderFunc, SharedConfig } from './interface';
import type { ScrollBarDirectionType, ScrollBarRef } from './ScrollBar';
import ScrollBar from './ScrollBar';
import { getSpinSize } from './utils/scrollbarUtil';

const EMPTY_DATA = [];

const ScrollStyle: React.CSSProperties = {
  overflowY: 'auto',
  overflowAnchor: 'none',
};

export interface ScrollInfo {
  x: number;
  y: number;
}

export type ScrollConfig = ScrollTarget | ScrollPos;

export type ScrollTo = (arg: number | ScrollConfig) => void;

export type ListRef = {
  nativeElement: HTMLDivElement;
  scrollTo: ScrollTo;
  getScrollInfo: () => ScrollInfo;
};

export interface ListProps<T> extends Omit<React.HTMLAttributes<any>, 'children'> {
  prefixCls?: string;
  children: RenderFunc<T>;
  data: T[];
  height?: number;
  itemHeight?: number;
  /** If not match virtual scroll condition, Set List still use height of container. */
  fullHeight?: boolean;
  itemKey: React.Key | ((item: T) => React.Key);
  component?: string | React.FC<any> | React.ComponentClass<any>;
  /** Set \`false\` will always use real scroll instead of virtual one */
  virtual?: boolean;
  direction?: ScrollBarDirectionType;
  /**
   * By default \`scrollWidth\` is same as container.
   * When set this, it will show the horizontal scrollbar and
   * \`scrollWidth\` will be used as the real width instead of container width.
   * When set, \`virtual\` will always be enabled.
   */
  scrollWidth?: number;

  styles?: {
    horizontalScrollBar?: React.CSSProperties;
    horizontalScrollBarThumb?: React.CSSProperties;
    verticalScrollBar?: React.CSSProperties;
    verticalScrollBarThumb?: React.CSSProperties;
  };

  onScroll?: React.UIEventHandler<HTMLElement>;

  /**
   * Given the virtual offset value.
   * It's the logic offset from start position.
   */
  onVirtualScroll?: (info: ScrollInfo) => void;

  /** Trigger when render list item changed */
  onVisibleChange?: (visibleList: T[], fullList: T[]) => void;

  /** Inject to inner container props. Only use when you need pass aria related data */
  innerProps?: InnerProps;

  /** Render extra content into Filler */
  extraRender?: (info: ExtraRenderInfo) => React.ReactNode;
}

export function RawList<T>(props: ListProps<T>, ref: React.Ref<ListRef>) {
  const {
    prefixCls = 'rc-virtual-list',
    className,
    height,
    itemHeight,
    fullHeight = true,
    style,
    data,
    children,
    itemKey,
    virtual,
    direction,
    scrollWidth,
    component: Component = 'div',
    onScroll,
    onVirtualScroll,
    onVisibleChange,
    innerProps,
    extraRender,
    styles,
    ...restProps
  } = props;

  // =============================== Item Key ===============================
  const getKey = React.useCallback<GetKey<T>>(
    (item: T) => {
      if (typeof itemKey === 'function') {
        return itemKey(item);
      }
      return item?.[itemKey as string];
    },
    [itemKey],
  );

  // ================================ Height ================================
  const [setInstanceRef, collectHeight, heights, heightUpdatedMark] = useHeights(
    getKey,
    null,
    null,
  );

  // ================================= MISC =================================
  const useVirtual = !!(virtual !== false && height && itemHeight);
  const containerHeight = React.useMemo(
    () => Object.values(heights.maps).reduce((total, curr) => total + curr, 0),
    [heights.id, heights.maps],
  );
  const inVirtual =
    useVirtual &&
    data &&
    (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
  const isRTL = direction === 'rtl';

  const mergedClassName = classNames(prefixCls, { [\`\${prefixCls}-rtl\`]: isRTL }, className);
  const mergedData = data || EMPTY_DATA;
  const componentRef = useRef<HTMLDivElement>();
  const fillerInnerRef = useRef<HTMLDivElement>();
  const containerRef = useRef<HTMLDivElement>();

  // =============================== Item Key ===============================

  const [offsetTop, setOffsetTop] = useState(0);
  const [offsetLeft, setOffsetLeft] = useState(0);
  const [scrollMoving, setScrollMoving] = useState(false);

  const onScrollbarStartMove = () => {
    setScrollMoving(true);
  };
  const onScrollbarStopMove = () => {
    setScrollMoving(false);
  };

  const sharedConfig: SharedConfig<T> = {
    getKey,
  };

  // ================================ Scroll ================================
  function syncScrollTop(newTop: number | ((prev: number) => number)) {
    setOffsetTop((origin) => {
      let value: number;
      if (typeof newTop === 'function') {
        value = newTop(origin);
      } else {
        value = newTop;
      }

      const alignedTop = keepInRange(value);

      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }

  // ================================ Legacy ================================
  // Put ref here since the range is generate by follow
  const rangeRef = useRef({ start: 0, end: mergedData.length });

  const diffItemRef = useRef<T>();
  const [diffItem] = useDiffItem(mergedData, getKey);
  diffItemRef.current = diffItem;

  // ========================== Visible Calculation =========================
  const {
    scrollHeight,
    start,
    end,
    offset: fillerOffset,
  } = React.useMemo(() => {
    if (!useVirtual) {
      return {
        scrollHeight: undefined,
        start: 0,
        end: mergedData.length - 1,
        offset: undefined,
      };
    }

    // Always use virtual scroll bar in avoid shaking
    if (!inVirtual) {
      return {
        scrollHeight: fillerInnerRef.current?.offsetHeight || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: undefined,
      };
    }

    let itemTop = 0;
    let startIndex: number;
    let startOffset: number;
    let endIndex: number;

    const dataLen = mergedData.length;
    for (let i = 0; i < dataLen; i += 1) {
      const item = mergedData[i];
      const key = getKey(item);

      const cacheHeight = heights.get(key);
      const currentItemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);

      // Check item top in the range
      if (currentItemBottom >= offsetTop && startIndex === undefined) {
        startIndex = i;
        startOffset = itemTop;
      }

      // Check item bottom in the range. We will render additional one item for motion usage
      if (currentItemBottom > offsetTop + height && endIndex === undefined) {
        endIndex = i;
      }

      itemTop = currentItemBottom;
    }

    // When scrollTop at the end but data cut to small count will reach this
    if (startIndex === undefined) {
      startIndex = 0;
      startOffset = 0;

      endIndex = Math.ceil(height / itemHeight);
    }
    if (endIndex === undefined) {
      endIndex = mergedData.length - 1;
    }

    // Give cache to improve scroll experience
    endIndex = Math.min(endIndex + 1, mergedData.length - 1);

    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset,
    };
  }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]);

  rangeRef.current.start = start;
  rangeRef.current.end = end;

  // ================================= Size =================================
  const [size, setSize] = React.useState({ width: 0, height });

  const onHolderResize: ResizeObserverProps['onResize'] = (sizeInfo) => {
    setSize({
      width: sizeInfo.offsetWidth,
      height: sizeInfo.offsetHeight,
    });
  };

  // Hack on scrollbar to enable flash call
  const verticalScrollBarRef = useRef<ScrollBarRef>();
  const horizontalScrollBarRef = useRef<ScrollBarRef>();

  const horizontalScrollBarSpinSize = React.useMemo(
    () => getSpinSize(size.width, scrollWidth),
    [size.width, scrollWidth],
  );
  const verticalScrollBarSpinSize = React.useMemo(
    () => getSpinSize(size.height, scrollHeight),
    [size.height, scrollHeight],
  );

  // =============================== In Range ===============================
  const maxScrollHeight = scrollHeight - height;
  const maxScrollHeightRef = useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;

  function keepInRange(newScrollTop: number) {
    let newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }

  const isScrollAtTop = offsetTop <= 0;
  const isScrollAtBottom = offsetTop >= maxScrollHeight;
  const isScrollAtLeft = offsetLeft <= 0;
  const isScrollAtRight = offsetLeft >= scrollWidth;

  const originScroll = useOriginScroll(
    isScrollAtTop,
    isScrollAtBottom,
    isScrollAtLeft,
    isScrollAtRight,
  );

  // ================================ Scroll ================================
  const getVirtualScrollInfo = () => ({
    x: isRTL ? -offsetLeft : offsetLeft,
    y: offsetTop,
  });

  const lastVirtualScrollInfoRef = useRef(getVirtualScrollInfo());

  const triggerScroll = useEvent((params?: { x?: number; y?: number }) => {
    if (onVirtualScroll) {
      const nextInfo = { ...getVirtualScrollInfo(), ...params };

      // Trigger when offset changed
      if (
        lastVirtualScrollInfoRef.current.x !== nextInfo.x ||
        lastVirtualScrollInfoRef.current.y !== nextInfo.y
      ) {
        onVirtualScroll(nextInfo);

        lastVirtualScrollInfoRef.current = nextInfo;
      }
    }
  });

  function onScrollBar(newScrollOffset: number, horizontal?: boolean) {
    const newOffset = newScrollOffset;

    if (horizontal) {
      flushSync(() => {
        setOffsetLeft(newOffset);
      });
      triggerScroll();
    } else {
      syncScrollTop(newOffset);
    }
  }

  // When data size reduce. It may trigger native scroll event back to fit scroll position
  function onFallbackScroll(e: React.UIEvent<HTMLDivElement>) {
    const { scrollTop: newScrollTop } = e.currentTarget;
    if (newScrollTop !== offsetTop) {
      syncScrollTop(newScrollTop);
    }

    // Trigger origin onScroll
    onScroll?.(e);
    triggerScroll();
  }

  const keepInHorizontalRange = (nextOffsetLeft: number) => {
    let tmpOffsetLeft = nextOffsetLeft;
    const max = !!scrollWidth ? scrollWidth - size.width : 0;
    tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
    tmpOffsetLeft = Math.min(tmpOffsetLeft, max);

    return tmpOffsetLeft;
  };

  const onWheelDelta: Parameters<typeof useFrameWheel>[6] = useEvent((offsetXY, fromHorizontal) => {
    if (fromHorizontal) {
      // Horizontal scroll no need sync virtual position

      flushSync(() => {
        setOffsetLeft((left) => {
          const nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);

          return keepInHorizontalRange(nextOffsetLeft);
        });
      });

      triggerScroll();
    } else {
      syncScrollTop((top) => {
        const newTop = top + offsetXY;
        return newTop;
      });
    }
  });

  // Since this added in global,should use ref to keep update
  const [onRawWheel, onFireFoxScroll] = useFrameWheel(
    useVirtual,
    isScrollAtTop,
    isScrollAtBottom,
    isScrollAtLeft,
    isScrollAtRight,
    !!scrollWidth,
    onWheelDelta,
  );

  // Mobile touch move
  useMobileTouchMove(useVirtual, componentRef, (isHorizontal, delta, smoothOffset) => {
    if (originScroll(isHorizontal, delta, smoothOffset)) {
      return false;
    }

    onRawWheel({
      preventDefault() {},
      deltaX: isHorizontal ? delta : 0,
      deltaY: isHorizontal ? 0 : delta,
    } as WheelEvent);
    return true;
  });

  useLayoutEffect(() => {
    // Firefox only
    function onMozMousePixelScroll(e: Event) {
      if (useVirtual) {
        e.preventDefault();
      }
    }

    const componentEle = componentRef.current;
    componentEle.addEventListener('wheel', onRawWheel, { passive: false });
    componentEle.addEventListener('DOMMouseScroll', onFireFoxScroll as any, { passive: true });
    componentEle.addEventListener('MozMousePixelScroll', onMozMousePixelScroll, { passive: false });

    return () => {
      componentEle.removeEventListener('wheel', onRawWheel);
      componentEle.removeEventListener('DOMMouseScroll', onFireFoxScroll as any);
      componentEle.removeEventListener('MozMousePixelScroll', onMozMousePixelScroll as any);
    };
  }, [useVirtual]);

  // Sync scroll left
  useLayoutEffect(() => {
    if (scrollWidth) {
      const newOffsetLeft = keepInHorizontalRange(offsetLeft);
      setOffsetLeft(newOffsetLeft);
      triggerScroll({ x: newOffsetLeft });
    }
  }, [size.width, scrollWidth]);

  // ================================= Ref ==================================
  const delayHideScrollBar = () => {
    verticalScrollBarRef.current?.delayHidden();
    horizontalScrollBarRef.current?.delayHidden();
  };

  const scrollTo = useScrollTo<T>(
    componentRef,
    mergedData,
    heights,
    itemHeight,
    getKey,
    () => collectHeight(true),
    syncScrollTop,
    delayHideScrollBar,
  );

  React.useImperativeHandle(ref, () => ({
    nativeElement: containerRef.current,
    getScrollInfo: getVirtualScrollInfo,
    scrollTo: (config) => {
      function isPosScroll(arg: any): arg is ScrollPos {
        return arg && typeof arg === 'object' && ('left' in arg || 'top' in arg);
      }

      if (isPosScroll(config)) {
        // Scroll X
        if (config.left !== undefined) {
          setOffsetLeft(keepInHorizontalRange(config.left));
        }

        // Scroll Y
        scrollTo(config.top);
      } else {
        scrollTo(config);
      }
    },
  }));

  // ================================ Effect ================================
  /** We need told outside that some list not rendered */
  useLayoutEffect(() => {
    if (onVisibleChange) {
      const renderList = mergedData.slice(start, end + 1);

      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);

  // ================================ Extra =================================
  const getSize = useGetSize(mergedData, getKey, heights, itemHeight);

  const extraContent = extraRender?.({
    start,
    end,
    virtual: inVirtual,
    offsetX: offsetLeft,
    offsetY: fillerOffset,
    rtl: isRTL,
    getSize,
  });

  // ================================ Render ================================
  const listChildren = useChildren(
    mergedData,
    start,
    end,
    scrollWidth,
    offsetLeft,
    setInstanceRef,
    children,
    sharedConfig,
  );

  let componentStyle: React.CSSProperties = null;
  if (height) {
    componentStyle = { [fullHeight ? 'height' : 'maxHeight']: height, ...ScrollStyle };

    if (useVirtual) {
      componentStyle.overflowY = 'hidden';

      if (scrollWidth) {
        componentStyle.overflowX = 'hidden';
      }

      if (scrollMoving) {
        componentStyle.pointerEvents = 'none';
      }
    }
  }

  const containerProps: React.HTMLAttributes<HTMLDivElement> = {};
  if (isRTL) {
    containerProps.dir = 'rtl';
  }

  return (
    <div
      ref={containerRef}
      style={{
        ...style,
        position: 'relative',
      }}
      className={mergedClassName}
      {...containerProps}
      {...restProps}
    >
      <ResizeObserver onResize={onHolderResize}>
        <Component
          className={\`\${prefixCls}-holder\`}
          style={componentStyle}
          ref={componentRef}
          onScroll={onFallbackScroll}
          onMouseEnter={delayHideScrollBar}
        >
          <Filler
            prefixCls={prefixCls}
            height={scrollHeight}
            offsetX={offsetLeft}
            offsetY={fillerOffset}
            scrollWidth={scrollWidth}
            onInnerResize={collectHeight}
            ref={fillerInnerRef}
            innerProps={innerProps}
            rtl={isRTL}
            extra={extraContent}
          >
            {listChildren}
          </Filler>
        </Component>
      </ResizeObserver>

      {inVirtual && scrollHeight > height && (
        <ScrollBar
          ref={verticalScrollBarRef}
          prefixCls={prefixCls}
          scrollOffset={offsetTop}
          scrollRange={scrollHeight}
          rtl={isRTL}
          onScroll={onScrollBar}
          onStartMove={onScrollbarStartMove}
          onStopMove={onScrollbarStopMove}
          spinSize={verticalScrollBarSpinSize}
          containerSize={size.height}
          style={styles?.verticalScrollBar}
          thumbStyle={styles?.verticalScrollBarThumb}
        />
      )}

      {inVirtual && scrollWidth > size.width && (
        <ScrollBar
          ref={horizontalScrollBarRef}
          prefixCls={prefixCls}
          scrollOffset={offsetLeft}
          scrollRange={scrollWidth}
          rtl={isRTL}
          onScroll={onScrollBar}
          onStartMove={onScrollbarStartMove}
          onStopMove={onScrollbarStopMove}
          spinSize={horizontalScrollBarSpinSize}
          containerSize={size.width}
          horizontal
          style={styles?.horizontalScrollBar}
          thumbStyle={styles?.horizontalScrollBarThumb}
        />
      )}
    </div>
  );
}

const List = React.forwardRef<ListRef, ListProps<any>>(RawList);

List.displayName = 'List';

export default List as <Item = any>(
  props: ListProps<Item> & { ref?: React.Ref<ListRef> },
) => React.ReactElement;
`},14409:function(o,e){e.Z=`import classNames from 'classnames';
import raf from 'rc-util/lib/raf';
import * as React from 'react';

export type ScrollBarDirectionType = 'ltr' | 'rtl';

export interface ScrollBarProps {
  prefixCls: string;
  scrollOffset: number;
  scrollRange: number;
  rtl: boolean;
  onScroll: (scrollOffset: number, horizontal?: boolean) => void;
  onStartMove: () => void;
  onStopMove: () => void;
  horizontal?: boolean;
  style?: React.CSSProperties;
  thumbStyle?: React.CSSProperties;
  spinSize: number;
  containerSize: number;
}

export interface ScrollBarRef {
  delayHidden: () => void;
}

function getPageXY(
  e: React.MouseEvent | React.TouchEvent | MouseEvent | TouchEvent,
  horizontal: boolean,
) {
  const obj = 'touches' in e ? e.touches[0] : e;
  return obj[horizontal ? 'pageX' : 'pageY'];
}

const ScrollBar = React.forwardRef<ScrollBarRef, ScrollBarProps>((props, ref) => {
  const {
    prefixCls,
    rtl,
    scrollOffset,
    scrollRange,
    onStartMove,
    onStopMove,
    onScroll,
    horizontal,
    spinSize,
    containerSize,
    style,
    thumbStyle: propsThumbStyle,
  } = props;

  const [dragging, setDragging] = React.useState(false);
  const [pageXY, setPageXY] = React.useState<number | null>(null);
  const [startTop, setStartTop] = React.useState<number | null>(null);

  const isLTR = !rtl;

  // ========================= Refs =========================
  const scrollbarRef = React.useRef<HTMLDivElement>();
  const thumbRef = React.useRef<HTMLDivElement>();

  // ======================= Visible ========================
  const [visible, setVisible] = React.useState(false);
  const visibleTimeoutRef = React.useRef<ReturnType<typeof setTimeout>>();

  const delayHidden = () => {
    clearTimeout(visibleTimeoutRef.current);
    setVisible(true);

    visibleTimeoutRef.current = setTimeout(() => {
      setVisible(false);
    }, 3000);
  };

  // ======================== Range =========================
  const enableScrollRange = scrollRange - containerSize || 0;
  const enableOffsetRange = containerSize - spinSize || 0;

  // ========================= Top ==========================
  const top = React.useMemo(() => {
    if (scrollOffset === 0 || enableScrollRange === 0) {
      return 0;
    }
    const ptg = scrollOffset / enableScrollRange;
    return ptg * enableOffsetRange;
  }, [scrollOffset, enableScrollRange, enableOffsetRange]);

  // ====================== Container =======================
  const onContainerMouseDown: React.MouseEventHandler = (e) => {
    e.stopPropagation();
    e.preventDefault();
  };

  // ======================== Thumb =========================
  const stateRef = React.useRef({ top, dragging, pageY: pageXY, startTop });
  stateRef.current = { top, dragging, pageY: pageXY, startTop };

  const onThumbMouseDown = (e: React.MouseEvent | React.TouchEvent | TouchEvent) => {
    setDragging(true);
    setPageXY(getPageXY(e, horizontal));
    setStartTop(stateRef.current.top);

    onStartMove();
    e.stopPropagation();
    e.preventDefault();
  };

  // ======================== Effect ========================

  // React make event as passive, but we need to preventDefault
  // Add event on dom directly instead.
  // ref: https://github.com/facebook/react/issues/9809
  React.useEffect(() => {
    const onScrollbarTouchStart = (e: TouchEvent) => {
      e.preventDefault();
    };

    const scrollbarEle = scrollbarRef.current;
    const thumbEle = thumbRef.current;
    scrollbarEle.addEventListener('touchstart', onScrollbarTouchStart, { passive: false });
    thumbEle.addEventListener('touchstart', onThumbMouseDown, { passive: false });

    return () => {
      scrollbarEle.removeEventListener('touchstart', onScrollbarTouchStart);
      thumbEle.removeEventListener('touchstart', onThumbMouseDown);
    };
  }, []);

  // Pass to effect
  const enableScrollRangeRef = React.useRef<number>();
  enableScrollRangeRef.current = enableScrollRange;
  const enableOffsetRangeRef = React.useRef<number>();
  enableOffsetRangeRef.current = enableOffsetRange;

  React.useEffect(() => {
    if (dragging) {
      let moveRafId: number;

      const onMouseMove = (e: MouseEvent | TouchEvent) => {
        const {
          dragging: stateDragging,
          pageY: statePageY,
          startTop: stateStartTop,
        } = stateRef.current;
        raf.cancel(moveRafId);

        const rect = scrollbarRef.current.getBoundingClientRect();
        const scale = containerSize / (horizontal ? rect.width : rect.height);

        if (stateDragging) {
          const offset = (getPageXY(e, horizontal) - statePageY) * scale;
          let newTop = stateStartTop;

          if (!isLTR && horizontal) {
            newTop -= offset;
          } else {
            newTop += offset;
          }

          const tmpEnableScrollRange = enableScrollRangeRef.current;
          const tmpEnableOffsetRange = enableOffsetRangeRef.current;

          const ptg: number = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;

          let newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
          newScrollTop = Math.max(newScrollTop, 0);
          newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);

          moveRafId = raf(() => {
            onScroll(newScrollTop, horizontal);
          });
        }
      };

      const onMouseUp = () => {
        setDragging(false);

        onStopMove();
      };

      window.addEventListener('mousemove', onMouseMove, { passive: true });
      window.addEventListener('touchmove', onMouseMove, { passive: true });
      window.addEventListener('mouseup', onMouseUp, { passive: true });
      window.addEventListener('touchend', onMouseUp, { passive: true });

      return () => {
        window.removeEventListener('mousemove', onMouseMove);
        window.removeEventListener('touchmove', onMouseMove);
        window.removeEventListener('mouseup', onMouseUp);
        window.removeEventListener('touchend', onMouseUp);

        raf.cancel(moveRafId);
      };
    }
  }, [dragging]);

  React.useEffect(() => {
    delayHidden();
    return () => {
      clearTimeout(visibleTimeoutRef.current);
    };
  }, [scrollOffset]);

  // ====================== Imperative ======================
  React.useImperativeHandle(ref, () => ({
    delayHidden,
  }));

  // ======================== Render ========================
  const scrollbarPrefixCls = \`\${prefixCls}-scrollbar\`;

  const containerStyle: React.CSSProperties = {
    position: 'absolute',
    visibility: visible ? null : 'hidden',
  };

  const thumbStyle: React.CSSProperties = {
    position: 'absolute',
    background: 'rgba(0, 0, 0, 0.5)',
    borderRadius: 99,
    cursor: 'pointer',
    userSelect: 'none',
  };

  if (horizontal) {
    // Container
    containerStyle.height = 8;
    containerStyle.left = 0;
    containerStyle.right = 0;
    containerStyle.bottom = 0;

    // Thumb
    thumbStyle.height = '100%';
    thumbStyle.width = spinSize;

    if (isLTR) {
      thumbStyle.left = top;
    } else {
      thumbStyle.right = top;
    }
  } else {
    // Container
    containerStyle.width = 8;
    containerStyle.top = 0;
    containerStyle.bottom = 0;

    if (isLTR) {
      containerStyle.right = 0;
    } else {
      containerStyle.left = 0;
    }

    // Thumb
    thumbStyle.width = '100%';
    thumbStyle.height = spinSize;
    thumbStyle.top = top;
  }

  return (
    <div
      ref={scrollbarRef}
      className={classNames(scrollbarPrefixCls, {
        [\`\${scrollbarPrefixCls}-horizontal\`]: horizontal,
        [\`\${scrollbarPrefixCls}-vertical\`]: !horizontal,
        [\`\${scrollbarPrefixCls}-visible\`]: visible,
      })}
      style={{ ...containerStyle, ...style }}
      onMouseDown={onContainerMouseDown}
      onMouseMove={delayHidden}
    >
      <div
        ref={thumbRef}
        className={classNames(\`\${scrollbarPrefixCls}-thumb\`, {
          [\`\${scrollbarPrefixCls}-thumb-moving\`]: dragging,
        })}
        style={{ ...thumbStyle, ...propsThumbStyle }}
        onMouseDown={onThumbMouseDown}
      />
    </div>
  );
});

if (process.env.NODE_ENV !== 'production') {
  ScrollBar.displayName = 'ScrollBar';
}

export default ScrollBar;
`},86857:function(o,e){e.Z=`import * as React from 'react';
import type { RenderFunc, SharedConfig } from '../interface';
import { Item } from '../Item';

export default function useChildren<T>(
  list: T[],
  startIndex: number,
  endIndex: number,
  scrollWidth: number,
  offsetX: number,
  setNodeRef: (item: T, element: HTMLElement) => void,
  renderFunc: RenderFunc<T>,
  { getKey }: SharedConfig<T>,
) {
  return list.slice(startIndex, endIndex + 1).map((item, index) => {
    const eleIndex = startIndex + index;
    const node = renderFunc(item, eleIndex, {
      style: {
        width: scrollWidth,
      },
      offsetX,
    }) as React.ReactElement;

    const key = getKey(item);
    return (
      <Item key={key} setRef={(ele) => setNodeRef(item, ele)}>
        {node}
      </Item>
    );
  });
}
`},23709:function(o,e){e.Z=`import * as React from 'react';
import { findListDiffIndex } from '../utils/algorithmUtil';
import type { GetKey } from '../interface';

export default function useDiffItem<T>(
  data: T[],
  getKey: GetKey<T>,
  onDiff?: (diffIndex: number) => void,
): [T] {
  const [prevData, setPrevData] = React.useState(data);
  const [diffItem, setDiffItem] = React.useState(null);

  React.useEffect(() => {
    const diff = findListDiffIndex(prevData || [], data || [], getKey);
    if (diff?.index !== undefined) {
      onDiff?.(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);

  return [diffItem];
}
`},73706:function(o,e){e.Z=`import raf from 'rc-util/lib/raf';
import { useRef } from 'react';
import isFF from '../utils/isFirefox';
import useOriginScroll from './useOriginScroll';

interface FireFoxDOMMouseScrollEvent {
  detail: number;
  preventDefault: VoidFunction;
}

export default function useFrameWheel(
  inVirtual: boolean,
  isScrollAtTop: boolean,
  isScrollAtBottom: boolean,
  isScrollAtLeft: boolean,
  isScrollAtRight: boolean,
  horizontalScroll: boolean,
  /***
   * Return \`true\` when you need to prevent default event
   */
  onWheelDelta: (offset: number, horizontal?: boolean) => void,
): [(e: WheelEvent) => void, (e: FireFoxDOMMouseScrollEvent) => void] {
  const offsetRef = useRef(0);
  const nextFrameRef = useRef<number>(null);

  // Firefox patch
  const wheelValueRef = useRef<number>(null);
  const isMouseScrollRef = useRef<boolean>(false);

  // Scroll status sync
  const originScroll = useOriginScroll(
    isScrollAtTop,
    isScrollAtBottom,
    isScrollAtLeft,
    isScrollAtRight,
  );

  function onWheelY(event: WheelEvent, deltaY: number) {
    raf.cancel(nextFrameRef.current);

    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;

    // Do nothing when scroll at the edge, Skip check when is in scroll
    if (originScroll(false, deltaY)) return;

    // Proxy of scroll events
    if (!isFF) {
      event.preventDefault();
    }

    nextFrameRef.current = raf(() => {
      // Patch a multiple for Firefox to fix wheel number too small
      // ref: https://github.com/ant-design/ant-design/issues/26372#issuecomment-679460266
      const patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }

  function onWheelX(event: WheelEvent, deltaX: number) {
    onWheelDelta(deltaX, true);

    if (!isFF) {
      event.preventDefault();
    }
  }

  // Check for which direction does wheel do. \`sx\` means \`shift + wheel\`
  const wheelDirectionRef = useRef<'x' | 'y' | 'sx' | null>(null);
  const wheelDirectionCleanRef = useRef<number>(null);

  function onWheel(event: WheelEvent) {
    if (!inVirtual) return;

    // Wait for 2 frame to clean direction
    raf.cancel(wheelDirectionCleanRef.current);
    wheelDirectionCleanRef.current = raf(() => {
      wheelDirectionRef.current = null;
    }, 2);

    const { deltaX, deltaY, shiftKey } = event;

    let mergedDeltaX = deltaX;
    let mergedDeltaY = deltaY;

    if (
      wheelDirectionRef.current === 'sx' ||
      (!wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX)
    ) {
      mergedDeltaX = deltaY;
      mergedDeltaY = 0;

      wheelDirectionRef.current = 'sx';
    }

    const absX = Math.abs(mergedDeltaX);
    const absY = Math.abs(mergedDeltaY);

    if (wheelDirectionRef.current === null) {
      wheelDirectionRef.current = horizontalScroll && absX > absY ? 'x' : 'y';
    }

    if (wheelDirectionRef.current === 'y') {
      onWheelY(event, mergedDeltaY);
    } else {
      onWheelX(event, mergedDeltaX);
    }
  }

  // A patch for firefox
  function onFireFoxScroll(event: FireFoxDOMMouseScrollEvent) {
    if (!inVirtual) return;

    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }

  return [onWheel, onFireFoxScroll];
}
`},43021:function(o,e){e.Z=`import type CacheMap from '../utils/CacheMap';
import type { GetKey, GetSize } from '../interface';
import * as React from 'react';

/**
 * Size info need loop query for the \`heights\` which will has the perf issue.
 * Let cache result for each render phase.
 */
export function useGetSize<T>(
  mergedData: T[],
  getKey: GetKey<T>,
  heights: CacheMap,
  itemHeight: number,
) {
  const [key2Index, bottomList] = React.useMemo<
    [key2Index: Map<React.Key, number>, bottomList: number[]]
  >(() => [new Map(), []], [mergedData, heights.id, itemHeight]);

  const getSize: GetSize = (startKey, endKey = startKey) => {
    // Get from cache first
    let startIndex = key2Index.get(startKey);
    let endIndex = key2Index.get(endKey);

    // Loop to fill the cache
    if (startIndex === undefined || endIndex === undefined) {
      const dataLen = mergedData.length;
      for (let i = bottomList.length; i < dataLen; i += 1) {
        const item = mergedData[i];
        const key = getKey(item);
        key2Index.set(key, i);
        const cacheHeight = heights.get(key) ?? itemHeight;
        bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
        if (key === startKey) {
          startIndex = i;
        }
        if (key === endKey) {
          endIndex = i;
        }

        if (startIndex !== undefined && endIndex !== undefined) {
          break;
        }
      }
    }

    return {
      top: bottomList[startIndex - 1] || 0,
      bottom: bottomList[endIndex],
    };
  };

  return getSize;
}
`},32655:function(o,e){e.Z=`import * as React from 'react';
import { useRef, useEffect } from 'react';
import findDOMNode from 'rc-util/lib/Dom/findDOMNode';
import raf from 'rc-util/lib/raf';
import type { GetKey } from '../interface';
import CacheMap from '../utils/CacheMap';

export default function useHeights<T>(
  getKey: GetKey<T>,
  onItemAdd?: (item: T) => void,
  onItemRemove?: (item: T) => void,
): [
  setInstanceRef: (item: T, instance: HTMLElement) => void,
  collectHeight: (sync?: boolean) => void,
  cacheMap: CacheMap,
  updatedMark: number,
] {
  const [updatedMark, setUpdatedMark] = React.useState(0);
  const instanceRef = useRef(new Map<React.Key, HTMLElement>());
  const heightsRef = useRef(new CacheMap());
  const collectRafRef = useRef<number>();

  function cancelRaf() {
    raf.cancel(collectRafRef.current);
  }

  function collectHeight(sync = false) {
    cancelRaf();

    const doCollect = () => {
      instanceRef.current.forEach((element, key) => {
        if (element && element.offsetParent) {
          const htmlElement = findDOMNode<HTMLElement>(element);
          const { offsetHeight } = htmlElement;
          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      });

      // Always trigger update mark to tell parent that should re-calculate heights when resized
      setUpdatedMark((c) => c + 1);
    };

    if (sync) {
      doCollect();
    } else {
      collectRafRef.current = raf(doCollect);
    }
  }

  function setInstanceRef(item: T, instance: HTMLElement) {
    const key = getKey(item);
    const origin = instanceRef.current.get(key);

    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }

    // Instance changed
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd?.(item);
      } else {
        onItemRemove?.(item);
      }
    }
  }

  useEffect(() => {
    return cancelRaf;
  }, []);

  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
`},97846:function(o,e){e.Z=`import useLayoutEffect from 'rc-util/lib/hooks/useLayoutEffect';
import type * as React from 'react';
import { useRef } from 'react';

const SMOOTH_PTG = 14 / 15;

export default function useMobileTouchMove(
  inVirtual: boolean,
  listRef: React.RefObject<HTMLDivElement>,
  callback: (isHorizontal: boolean, offset: number, smoothOffset?: boolean) => boolean,
) {
  const touchedRef = useRef(false);
  const touchXRef = useRef(0);
  const touchYRef = useRef(0);

  const elementRef = useRef<HTMLElement>(null);

  // Smooth scroll
  const intervalRef = useRef(null);

  /* eslint-disable prefer-const */
  let cleanUpEvents: () => void;

  const onTouchMove = (e: TouchEvent) => {
    if (touchedRef.current) {
      const currentX = Math.ceil(e.touches[0].pageX);
      const currentY = Math.ceil(e.touches[0].pageY);
      let offsetX = touchXRef.current - currentX;
      let offsetY = touchYRef.current - currentY;
      const isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
      if (isHorizontal) {
        touchXRef.current = currentX;
      } else {
        touchYRef.current = currentY;
      }

      if (callback(isHorizontal, isHorizontal ? offsetX : offsetY)) {
        e.preventDefault();
      }
      // Smooth interval
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(() => {
        if (isHorizontal) {
          offsetX *= SMOOTH_PTG;
        } else {
          offsetY *= SMOOTH_PTG;
        }
        const offset = Math.floor(isHorizontal ? offsetX : offsetY);
        if (!callback(isHorizontal, offset, true) || Math.abs(offset) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };

  const onTouchEnd = () => {
    touchedRef.current = false;

    cleanUpEvents();
  };

  const onTouchStart = (e: TouchEvent) => {
    cleanUpEvents();

    if (e.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchXRef.current = Math.ceil(e.touches[0].pageX);
      touchYRef.current = Math.ceil(e.touches[0].pageY);

      elementRef.current = e.target as HTMLElement;
      elementRef.current.addEventListener('touchmove', onTouchMove, { passive: false });
      elementRef.current.addEventListener('touchend', onTouchEnd, { passive: true });
    }
  };

  cleanUpEvents = () => {
    if (elementRef.current) {
      elementRef.current.removeEventListener('touchmove', onTouchMove);
      elementRef.current.removeEventListener('touchend', onTouchEnd);
    }
  };

  useLayoutEffect(() => {
    if (inVirtual) {
      listRef.current.addEventListener('touchstart', onTouchStart, { passive: true });
    }

    return () => {
      listRef.current?.removeEventListener('touchstart', onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
`},76529:function(o,e){e.Z=`import { useRef } from 'react';

export default (
  isScrollAtTop: boolean,
  isScrollAtBottom: boolean,
  isScrollAtLeft: boolean,
  isScrollAtRight: boolean,
) => {
  // Do lock for a wheel when scrolling
  const lockRef = useRef(false);
  const lockTimeoutRef = useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);

    lockRef.current = true;

    lockTimeoutRef.current = setTimeout(() => {
      lockRef.current = false;
    }, 50);
  }

  // Pass to ref since global add is in closure
  const scrollPingRef = useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom,
    left: isScrollAtLeft,
    right: isScrollAtRight,
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  scrollPingRef.current.left = isScrollAtLeft;
  scrollPingRef.current.right = isScrollAtRight;

  return (isHorizontal: boolean, delta: number, smoothOffset = false) => {
    const originScroll = isHorizontal
      ? // Pass origin wheel when on the left
        (delta < 0 && scrollPingRef.current.left) ||
        // Pass origin wheel when on the right
        (delta > 0 && scrollPingRef.current.right) // Pass origin wheel when on the top
      : (delta < 0 && scrollPingRef.current.top) ||
        // Pass origin wheel when on the bottom
        (delta > 0 && scrollPingRef.current.bottom);

    if (smoothOffset && originScroll) {
      // No need lock anymore when it's smooth offset from touchMove interval
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }

    return !lockRef.current && originScroll;
  };
};
`},23257:function(o,e){e.Z=`/* eslint-disable no-param-reassign */
import * as React from 'react';
import raf from 'rc-util/lib/raf';
import type { GetKey } from '../interface';
import type CacheMap from '../utils/CacheMap';
import useLayoutEffect from 'rc-util/lib/hooks/useLayoutEffect';
import { warning } from 'rc-util';

const MAX_TIMES = 10;

export type ScrollAlign = 'top' | 'bottom' | 'auto';

export type ScrollPos = {
  left?: number;
  top?: number;
};

export type ScrollTarget =
  | {
      index: number;
      align?: ScrollAlign;
      offset?: number;
    }
  | {
      key: React.Key;
      align?: ScrollAlign;
      offset?: number;
    };

export default function useScrollTo<T>(
  containerRef: React.RefObject<HTMLDivElement>,
  data: T[],
  heights: CacheMap,
  itemHeight: number,
  getKey: GetKey<T>,
  collectHeight: () => void,
  syncScrollTop: (newTop: number) => void,
  triggerFlash: () => void,
): (arg: number | ScrollTarget) => void {
  const scrollRef = React.useRef<number>();

  const [syncState, setSyncState] = React.useState<{
    times: number;
    index: number;
    offset: number;
    originAlign: ScrollAlign;
    targetAlign?: 'top' | 'bottom';
    lastTop?: number;
  }>(null);

  // ========================== Sync Scroll ==========================
  useLayoutEffect(() => {
    if (syncState && syncState.times < MAX_TIMES) {
      // Never reach
      if (!containerRef.current) {
        setSyncState((ori) => ({ ...ori }));
        return;
      }

      collectHeight();

      const { targetAlign, originAlign, index, offset } = syncState;

      const height = containerRef.current.clientHeight;
      let needCollectHeight = false;
      let newTargetAlign: 'top' | 'bottom' | null = targetAlign;
      let targetTop: number | null = null;

      // Go to next frame if height not exist
      if (height) {
        const mergedAlign = targetAlign || originAlign;

        // Get top & bottom
        let stackTop = 0;
        let itemTop = 0;
        let itemBottom = 0;

        const maxLen = Math.min(data.length - 1, index);

        for (let i = 0; i <= maxLen; i += 1) {
          const key = getKey(data[i]);
          itemTop = stackTop;
          const cacheHeight = heights.get(key);
          itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);

          stackTop = itemBottom;
        }

        // Check if need sync height (visible range has item not record height)
        let leftHeight = mergedAlign === 'top' ? offset : height - offset;
        for (let i = maxLen; i >= 0; i -= 1) {
          const key = getKey(data[i]);
          const cacheHeight = heights.get(key);

          if (cacheHeight === undefined) {
            needCollectHeight = true;
            break;
          }

          leftHeight -= cacheHeight;
          if (leftHeight <= 0) {
            break;
          }
        }

        // Scroll to
        switch (mergedAlign) {
          case 'top':
            targetTop = itemTop - offset;
            break;
          case 'bottom':
            targetTop = itemBottom - height + offset;
            break;

          default: {
            const { scrollTop } = containerRef.current;
            const scrollBottom = scrollTop + height;
            if (itemTop < scrollTop) {
              newTargetAlign = 'top';
            } else if (itemBottom > scrollBottom) {
              newTargetAlign = 'bottom';
            }
          }
        }

        if (targetTop !== null) {
          syncScrollTop(targetTop);
        }

        // One more time for sync
        if (targetTop !== syncState.lastTop) {
          needCollectHeight = true;
        }
      }

      // Trigger next effect
      if (needCollectHeight) {
        setSyncState({
          ...syncState,
          times: syncState.times + 1,
          targetAlign: newTargetAlign,
          lastTop: targetTop,
        });
      }
    } else if (process.env.NODE_ENV !== 'production' && syncState?.times === MAX_TIMES) {
      warning(
        false,
        'Seems \`scrollTo\` with \`rc-virtual-list\` reach the max limitation. Please fire issue for us. Thanks.',
      );
    }
  }, [syncState, containerRef.current]);

  // =========================== Scroll To ===========================
  return (arg) => {
    // When not argument provided, we think dev may want to show the scrollbar
    if (arg === null || arg === undefined) {
      triggerFlash();
      return;
    }

    // Normal scroll logic
    raf.cancel(scrollRef.current);

    if (typeof arg === 'number') {
      syncScrollTop(arg);
    } else if (arg && typeof arg === 'object') {
      let index: number;
      const { align } = arg;

      if ('index' in arg) {
        ({ index } = arg);
      } else {
        index = data.findIndex((item) => getKey(item) === arg.key);
      }

      const { offset = 0 } = arg;

      setSyncState({
        times: 0,
        index,
        offset,
        originAlign: align,
      });
    }
  };
}
`},40857:function(o,e){e.Z=`import type React from 'react';

// Firefox has low performance of map.
class CacheMap {
  maps: Record<string, number>;

  // Used for cache key
  // \`useMemo\` no need to update if \`id\` not change
  id: number = 0;

  constructor() {
    this.maps = Object.create(null);
  }

  set(key: React.Key, value: number) {
    this.maps[key as string] = value;
    this.id += 1;
  }

  get(key: React.Key) {
    return this.maps[key as string];
  }
}

export default CacheMap;
`},9290:function(o,e){e.Z=`import type * as React from 'react';
/**
 * Get index with specific start index one by one. e.g.
 * min: 3, max: 9, start: 6
 *
 * Return index is:
 * [0]: 6
 * [1]: 7
 * [2]: 5
 * [3]: 8
 * [4]: 4
 * [5]: 9
 * [6]: 3
 */
export function getIndexByStartLoc(min: number, max: number, start: number, index: number): number {
  const beforeCount = start - min;
  const afterCount = max - start;
  const balanceCount = Math.min(beforeCount, afterCount) * 2;

  // Balance
  if (index <= balanceCount) {
    const stepIndex = Math.floor(index / 2);
    if (index % 2) {
      return start + stepIndex + 1;
    }
    return start - stepIndex;
  }

  // One is out of range
  if (beforeCount > afterCount) {
    return start - (index - afterCount);
  }
  return start + (index - beforeCount);
}

/**
 * We assume that 2 list has only 1 item diff and others keeping the order.
 * So we can use dichotomy algorithm to find changed one.
 */
export function findListDiffIndex<T>(
  originList: T[],
  targetList: T[],
  getKey: (item: T) => React.Key,
): { index: number; multiple: boolean } | null {
  const originLen = originList.length;
  const targetLen = targetList.length;

  let shortList: T[];
  let longList: T[];

  if (originLen === 0 && targetLen === 0) {
    return null;
  }

  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }

  const notExistKey = { __EMPTY_ITEM__: true };
  function getItemKey(item: T) {
    if (item !== undefined) {
      return getKey(item);
    }
    return notExistKey;
  }

  // Loop to find diff one
  let diffIndex: number = null;
  let multiple = Math.abs(originLen - targetLen) !== 1;
  for (let i = 0; i < longList.length; i += 1) {
    const shortKey = getItemKey(shortList[i]);
    const longKey = getItemKey(longList[i]);

    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }

  return diffIndex === null ? null : { index: diffIndex, multiple };
}
`},70485:function(o,e){e.Z=`const isFF = typeof navigator === 'object' && /Firefox/i.test(navigator.userAgent);

export default isFF;
`},17579:function(o,e){e.Z=`const MIN_SIZE = 20;

export function getSpinSize(containerSize = 0, scrollRange = 0) {
  let baseSize = (containerSize / scrollRange) * containerSize;
  if (isNaN(baseSize)) {
    baseSize = 0;
  }
  baseSize = Math.max(baseSize, MIN_SIZE);
  return Math.floor(baseSize);
}
`}}]);
